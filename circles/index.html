<!DOCTYPE html>
<script src='vendor/three.js/build/three.js'></script>
<script src="vendor/require.js/require.js"></script>
<script src="vendor/three.js/examples/js/Detector.js"></script>
<script src="vendor/threex.windowresize.js"></script>
<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'><script>

buildAxes = function ( length ) {
        var axes = new THREE.Object3D();

        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
        axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z

        return axes;

      };

buildAxis = function ( src, dst, colorHex, dashed ) {
      var geom = new THREE.Geometry(),
        mat; 

      if(dashed) {
        mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
      } else {
        mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
      }

      geom.vertices.push( src.clone() );
      geom.vertices.push( dst.clone() );
      geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

      var axis = new THREE.Line( geom, mat, THREE.LineSegments );

      return axis;

}

THREE.Arc = function(a, b, radius){
	var normal = new THREE.Vector3();
	var z = new THREE.Vector3(0,0,1);

	normal.crossVectors( a, b );
	normal.normalize();
	var dot = a.dot(b)/(a.length()*b.length())

	var angle = a.angleTo(b);


	
	if (dot <0 && b.y<=0 ){
		//angle = 2*Math.PI-angle;
	}else if( dot == 0){

	}

	var curve = new THREE.EllipseCurve(
	    0, 0,             // ax, aY
	    radius, radius,            // xRadius, yRadius
	    0, angle, // aStartAngle, aEndAngle
	    true             // aClockwise
		);

	var points = curve.getSpacedPoints( 20 );

	var path = new THREE.Path();
	geometry = path.createGeometry( points );

	material = new THREE.LineBasicMaterial( { color : 0xff0000, linewidth: 3 } );

	var line = new THREE.Line( geometry, material );
	var m = new THREE.Matrix4();
	
	var y = new THREE.Vector3(0,1,0);
	var origin = new THREE.Vector3(0,0,0);
	m.lookAt(normal, origin, normal )

	geometry.applyMatrix(m);

	return line;
}



var circle;
require([], function(){
	// detect WebGL
	if( !Detector.webgl ){
		Detector.addGetWebGLMessage();
		throw 'WebGL Not Available'
	} 
	// setup webgl renderer full page
	var renderer	= new THREE.WebGLRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );
	// setup a scene and camera
	var scene	= new THREE.Scene();
	var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
	camera.position.z = 3;

	// declare the rendering loop
	var onRenderFcts= [];

	// handle window resize events
	var winResize	= new THREEx.WindowResize(renderer, camera)

	//////////////////////////////////////////////////////////////////////////////////
	//		default 3 points lightning					//
	//////////////////////////////////////////////////////////////////////////////////
	
	var ambientLight= new THREE.AmbientLight( 0x020202 )
	scene.add( ambientLight)
	var frontLight	= new THREE.DirectionalLight('white', 1)
	frontLight.position.set(0.5, 0.5, 2)
	scene.add( frontLight )
	var backLight	= new THREE.DirectionalLight('white', 0.75)
	backLight.position.set(-0.5, -0.5, -2)
	scene.add( backLight )		

	//////////////////////////////////////////////////////////////////////////////////
	//		add an object and make it move					//
	//////////////////////////////////////////////////////////////////////////////////	
	var    segments = 64,
	radius = 1.0,
    material = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 1 } ),
    geometry = new THREE.CircleGeometry( radius, segments );

	// Remove center vertex
	geometry.vertices.shift();

	var RAD2DEG = Math.PI/180.0;
	circle = new THREE.Line( geometry, material );
	
	var meridians = 36, parallels = 18;
	for(var i=0; i<meridians; ++i){
		circle.rotateY(360/meridians*RAD2DEG);		
		scene.add( circle.clone() );
	}
	var alpha = 0.0, deltaY;

	geometry = new THREE.CircleGeometry( radius, segments );	
	geometry.vertices.shift();
	circle = new THREE.Line( geometry, material );

	var x = new THREE.Vector3(1,0,0);
	circle.rotateOnAxis(x, Math.PI/2);
	
	//draw parallels
	for(var i=0; i<parallels; ++i){
		deltaY = radius*Math.cos(alpha);
		var r = radius*Math.sin(alpha);
		
		circle.scale.x=r;
		circle.scale.y=r;
		circle.scale.z=r;
		
		circle.position.y = -deltaY;		

		alpha += Math.PI/parallels;
		scene.add( circle.clone() );
	}


	//draw arc on sphere
	var curve = new THREE.EllipseCurve(
	    0, 0,             // ax, aY
	    radius, radius,            // xRadius, yRadius
	    0, 1/3 * Math.PI, // aStartAngle, aEndAngle
	    false             // aClockwise
		);

		var points = curve.getSpacedPoints( 20 );

		var path = new THREE.Path();
		geometry = path.createGeometry( points );

		material = new THREE.LineBasicMaterial( { color : 0xff0000, linewidth: 10 } );

		var line = new THREE.Line( geometry, material );
		var m = new THREE.Matrix4();
		var normal = new THREE.Vector3(-1,1,0);
		var y = new THREE.Vector3(0,1,0);
		var origin = new THREE.Vector3(0,0,0);
		m.lookAt(normal, origin, y )

		geometry.applyMatrix(m);
		//scene.add( line );


		var a = new THREE.Vector3(1, 0, 1);
		var b = new THREE.Vector3(1, -1, 0);
		scene.add(new THREE.Arc(a, b, radius));

	//draw axes
	scene.add(buildAxes(1000));
	//////////////////////////////////////////////////////////////////////////////////
	//		Camera Controls							//
	//////////////////////////////////////////////////////////////////////////////////
	var mouse	= {x : 0, y : 0}
	document.addEventListener('mousemove', function(event){
		mouse.x	= (event.clientX / window.innerWidth ) - 0.5
		mouse.y	= (event.clientY / window.innerHeight) - 0.5
	}, false)
	onRenderFcts.push(function(delta, now){
		camera.position.x += (mouse.x*5 - camera.position.x) * (delta*3)
		camera.position.y += (mouse.y*5 - camera.position.y) * (delta*3)
		camera.lookAt( scene.position )
	})

	//////////////////////////////////////////////////////////////////////////////////
	//		render the scene						//
	//////////////////////////////////////////////////////////////////////////////////
	onRenderFcts.push(function(){
		renderer.render( scene, camera );		
	})
	
	//////////////////////////////////////////////////////////////////////////////////
	//		Rendering Loop runner						//
	//////////////////////////////////////////////////////////////////////////////////
	var lastTimeMsec= null
	requestAnimationFrame(function animate(nowMsec){
		// keep looping
		requestAnimationFrame( animate );
		// measure time
		lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
		var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
		lastTimeMsec	= nowMsec
		// call each update function
		onRenderFcts.forEach(function(onRenderFct){
			onRenderFct(deltaMsec/1000, nowMsec/1000)
		})
	})


	

})
</script></body>
